local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local workspace = workspace

local WEBHOOK_URL = "https://discord.com/api/webhooks/1441062150880891010/oXdFqednQHdke74hQtRPmlQ8BQqRs8A3dmL54FxI-4QMJRUIi31ptjqgLeVPlS5uaEs-"
local PLOTS_NAME = "Plots"
local HOP_DELAY_SECONDS = 5
local MAX_SERVER_PAGES = 10
local MAX_PLAYERS_DISPLAY = 8
local SHOW_ESP = true
local MIN_GENERATION = 10000000
local TELEPORT_MAX_RETRIES = 5
local TELEPORT_RETRY_DELAY = 3

local function ciReplace(str, target, repl)
    if not str or not target or repl == nil then return str end
    local pat = ""
    for i = 1, #target do
        local c = target:sub(i,i)
        pat = pat .. "[" .. string.lower(c) .. string.upper(c) .. "]"
    end
    return (string.gsub(str, pat, repl))
end

local function doHttpRequest(opts)
    opts = opts or {}
    local url = opts.Url
    local method = opts.Method or "GET"
    local headers = opts.Headers or {}
    local body = opts.Body
    local timeout = opts.Timeout or 10
    
    local function normalize(res)
        if type(res) ~= "table" then
            return { Success = false, StatusCode = 0, Body = tostring(res) }
        end
        return {
            Success = res.Success or nil,
            StatusCode = res.StatusCode or res.status or res.statusCode or 0,
            Body = res.Body or res.body or (res.response and res.response.Body) or ""
        }
    end
    
    if syn and syn.request then
        local ok, res = pcall(function()
            return syn.request({ Url = url, Method = method, Headers = headers, Body = body, Timeout = timeout })
        end)
        if ok and res then return true, normalize(res) end
    end
    if http and http.request then
        local ok, res = pcall(function()
            return http.request({ Url = url, Method = method, Headers = headers, Body = body })
        end)
        if ok and res then return true, normalize(res) end
    end
    if type(http_request) == "function" then
        local ok, res = pcall(function() 
            return http_request({ Url = url, Method = method, Headers = headers, Body = body }) 
        end)
        if ok and res then return true, normalize(res) end
    end
    if type(request) == "function" then
        local ok, res = pcall(function() 
            return request({ Url = url, Method = method, Headers = headers, Body = body }) 
        end)
        if ok and res then return true, normalize(res) end
    end
    if HttpService and HttpService.PostAsync then
        local okPost, result = pcall(function()
            return HttpService:PostAsync(url, body or "", Enum.HttpContentType.ApplicationJson, false)
        end)
        if okPost then
            return true, { Success = true, StatusCode = 200, Body = result }
        else
            return false, { Success = false, StatusCode = 0, Body = tostring(result) }
        end
    end
    return false, { Success = false, StatusCode = 0, Body = "no-http-method-available" }
end

local function parseSuffixNumber(str)
    if not str or type(str) ~= "string" then return nil end
    local s = string.gsub(str, "%s+", ""):lower()
    s = string.gsub(s, ",", "")
    s = string.gsub(s, "%+", "")
    if string.sub(s,1,1) == "$" then s = string.sub(s,2) end
    s = string.gsub(s, "/.*$", "")
    s = string.gsub(s, "[^%w%.]+$", "")
    local numPart, suffix = string.match(s, "^([%d%.]+)([kmgtbq]?)")
    if not numPart then return nil end
    local n = tonumber(numPart)
    if not n then return nil end
    local multipliers = { k = 1e3, m = 1e6, b = 1e9, t = 1e12, q = 1e15 }
    local mul = 1
    if suffix and suffix ~= "" then mul = multipliers[suffix] or 1 end
    return n * mul
end

local function findDescendantByNameCI(root, name)
    if not root or not name then return nil end
    if string.lower(root.Name) == string.lower(name) then return root end
    for _, child in ipairs(root:GetChildren()) do
        local found = findDescendantByNameCI(child, name)
        if found then return found end
    end
    return nil
end

local function getTextFromInstance(inst)
    if not inst then return nil end
    local txt
    if inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox") then 
        txt = inst.Text 
    end
    if (not txt) and inst:IsA("ValueBase") then
        local v = inst.Value
        if v ~= nil then txt = tostring(v) end
    end
    if not txt then
        local ok, generic = pcall(function() return inst.Text end)
        if ok and generic then txt = generic end
    end
    if not txt then
        local ok2, generic2 = pcall(function() return inst.Value end)
        if ok2 and generic2 then txt = tostring(generic2) end
    end
    if not txt then return nil end
    txt = tostring(txt)
    txt = string.gsub(txt, "^%s+", "")
    txt = string.gsub(txt, "%s+$", "")
    return txt
end

local function findBasePartForPodium(podium)
    if not podium then return nil end
    local base = findDescendantByNameCI(podium, "Base")
    if base and base:IsA("BasePart") then return base end
    if base then
        for _, d in ipairs(base:GetDescendants()) do
            if d:IsA("BasePart") then return d end
        end
    end
    for _, d in ipairs(podium:GetDescendants()) do
        if d:IsA("BasePart") then return d end
    end
    return nil
end

local function clearESP()
    if not SHOW_ESP then return end
    for _, desc in ipairs(playerGui:GetDescendants()) do
        if desc:IsA("Highlight") or desc:IsA("ScreenGui") then
            if desc.Name == "BestPlotESP_Highlight" or desc.Name == "BestPlotESP_BillboardContainer" then
                desc:Destroy()
            end
        end
    end
    for _, desc in ipairs(workspace:GetDescendants()) do
        if desc:IsA("Highlight") and desc.Name == "BestPlotESP_Highlight" then 
            desc:Destroy() 
        end
    end
end

local function createHighlightForTarget(target)
    if not SHOW_ESP then return end
    if not target then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "BestPlotESP_Highlight"
    highlight.Adornee = target
    highlight.FillColor = Color3.fromRGB(0, 200, 150)
    highlight.FillTransparency = 0.6
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineTransparency = 0
    highlight.Parent = playerGui
    return highlight
end

local function createBillboardForPart(adorneePart, displayText)
    if not SHOW_ESP then return end
    if not adorneePart or not adorneePart:IsA("BasePart") then return end
    local container = playerGui:FindFirstChild("BestPlotESP_BillboardContainer")
    if not container then
        local sg = Instance.new("ScreenGui")
        sg.Name = "BestPlotESP_BillboardContainer"
        sg.ResetOnSpawn = false
        sg.Parent = playerGui
        container = sg
    end
    local bbg = Instance.new("BillboardGui")
    bbg.Name = "BestGenerationBillboard"
    bbg.Adornee = adorneePart
    bbg.Size = UDim2.new(0, 220, 0, 42)
    bbg.AlwaysOnTop = true
    bbg.StudsOffset = Vector3.new(0, adorneePart.Size.Y + 1.2, 0)
    bbg.Parent = container
    local label = Instance.new("TextLabel")
    label.Name = "GenLabel"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = tostring(displayText or "")
    label.TextColor3 = Color3.fromRGB(255, 221, 51)
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.TextStrokeTransparency = 0
    label.Font = Enum.Font.GothamBold
    label.TextScaled = true
    label.Parent = bbg
    return bbg
end

local function isPodiumIndex(name)
    if not name then return false end
    local n = tonumber(name)
    return n and n >= 1 and n <= 50 and math.floor(n) == n
end

local function highlightBestPodiumDecorations(podium, decorationsOverride)
    if not SHOW_ESP then return end
    if not podium then return end
    local decorations = decorationsOverride
    if not decorations then
        local base = findDescendantByNameCI(podium, "Base") or podium:FindFirstChild("Base")
        if base then 
            decorations = base:FindFirstChild("Decorations") or findDescendantByNameCI(base, "Decorations") 
        end
        if not decorations then 
            decorations = podium:FindFirstChild("Decorations") or findDescendantByNameCI(podium, "Decorations") 
        end
    end
    
    if decorations then
        if decorations:IsA("Model") or decorations:IsA("BasePart") then
            createHighlightForTarget(decorations)
        else
            for _, decoChild in ipairs(decorations:GetChildren()) do
                if decoChild:IsA("BasePart") or decoChild:IsA("Model") then
                    createHighlightForTarget(decoChild)
                else
                    for _, d in ipairs(decoChild:GetDescendants()) do
                        if d:IsA("BasePart") or d:IsA("Model") then
                            createHighlightForTarget(d)
                            break
                        end
                    end
                end
            end
        end
    end
end

local function findGenerationInDecorations(decorations)
    if not decorations then return nil end
    local bestNum, bestText, bestGenInst = nil, nil, nil
    local function checkInst(inst)
        local genText = getTextFromInstance(inst)
        if genText then
            local numeric = parseSuffixNumber(genText)
            if numeric then
                if (not bestNum) or numeric > bestNum then
                    bestNum = numeric
                    bestText = genText
                    bestGenInst = inst
                end
            end
        end
    end
    if string.lower(decorations.Name) == "generation" then checkInst(decorations) end
    for _, desc in ipairs(decorations:GetDescendants()) do
        if string.lower(desc.Name) == "generation" then checkInst(desc) end
    end
    if bestNum then return bestNum, bestText, bestGenInst end
    return nil
end

local function getRarityForPodium(podium, decorations)
    if decorations then
        if string.lower(decorations.Name) == "rarity" then
            local t = getTextFromInstance(decorations)
            if t and t ~= "" then return t end
        end
        for _, d in ipairs(decorations:GetDescendants()) do
            if string.lower(d.Name) == "rarity" then
                local t = getTextFromInstance(d)
                if t and t ~= "" then return t end
            end
        end
    end
    local base = findDescendantByNameCI(podium, "Base") or podium:FindFirstChild("Base")
    if base then
        local r = base:FindFirstChild("Rarity") or findDescendantByNameCI(base, "Rarity")
        if r then
            local t = getTextFromInstance(r)
            if t and t ~= "" then return t end
        end
        for _, d in ipairs(base:GetDescendants()) do
            if string.lower(d.Name) == "rarity" then
                local t = getTextFromInstance(d)
                if t and t ~= "" then return t end
            end
        end
    end
    local r = podium:FindFirstChild("Rarity") or findDescendantByNameCI(podium, "Rarity")
    if r then
        local t = getTextFromInstance(r)
        if t and t ~= "" then return t end
    end
    for _, d in ipairs(podium:GetDescendants()) do
        if string.lower(d.Name) == "rarity" then
            local t = getTextFromInstance(d)
            if t and t ~= "" then return t end
        end
    end
    local overhead = podium:FindFirstChild("AnimalOverhead") or findDescendantByNameCI(podium, "AnimalOverhead")
    if overhead then
        local r2 = overhead:FindFirstChild("Rarity") or findDescendantByNameCI(overhead, "Rarity")
        if r2 then
            local t = getTextFromInstance(r2)
            if t and t ~= "" then return t end
        end
        for _, d in ipairs(overhead:GetDescendants()) do
            if string.lower(d.Name) == "rarity" then
                local t = getTextFromInstance(d)
                if t and t ~= "" then return t end
            end
        end
    end
    return nil
end

local function extractDisplayNameFollowingPath(plot, podium, decorations, genInst)
    local function extractFromDecorationNode(decNode)
        if not decNode then return nil end
        local animalOverhead = findDescendantByNameCI(decNode, "AnimalOverhead")
        if animalOverhead then
            local disp = findDescendantByNameCI(animalOverhead, "DisplayName") or findDescendantByNameCI(animalOverhead, "Displayname")
            if disp then
                local txt = getTextFromInstance(disp)
                if txt and txt ~= "" then return txt end
            end
            local txt2 = getTextFromInstance(animalOverhead)
            if txt2 and txt2 ~= "" then return txt2 end
        end
        local decorationNode = findDescendantByNameCI(decNode, "Decoration") or findDescendantByNameCI(decNode, "Decor") or decNode
        if decorationNode then
            local part = findDescendantByNameCI(decorationNode, "Part") or findDescendantByNameCI(decorationNode, "BasePart")
            if not part then
                for _, d in ipairs(decorationNode:GetDescendants()) do
                    if d:IsA("BasePart") then
                        part = d
                        break
                    end
                end
            end
            if part then
                local spawn = findDescendantByNameCI(part, "Spawn") or findDescendantByNameCI(part, "SpawnLocation") or findDescendantByNameCI(decorationNode, "Spawn")
                local attachment
                if spawn then
                    attachment = findDescendantByNameCI(spawn, "Attachment") or findDescendantByNameCI(spawn, "Attachments")
                end
                if not attachment then
                    for _, d in ipairs(part:GetDescendants()) do
                        if d:IsA("Attachment") then
                            attachment = d
                            break
                        end
                    end
                end
                if attachment then
                    local ao = findDescendantByNameCI(attachment, "AnimalOverhead") or findDescendantByNameCI(decorationNode, "AnimalOverhead") or findDescendantByNameCI(part, "AnimalOverhead")
                    if ao then
                        local disp = findDescendantByNameCI(ao, "DisplayName") or findDescendantByNameCI(ao, "Displayname")
                        if disp then
                            local txt = getTextFromInstance(disp)
                            if txt and txt ~= "" then return txt end
                        end
                        local txt2 = getTextFromInstance(ao)
                        if txt2 and txt2 ~= "" then return txt2 end
                    end
                end
            end
        end
        local dispAny = findDescendantByNameCI(decNode, "DisplayName") or findDescendantByNameCI(decNode, "Displayname")
        if dispAny then
            local txt = getTextFromInstance(dispAny)
            if txt and txt ~= "" then return txt end
        end
        for _, d in ipairs(decNode:GetDescendants()) do
            local lname = string.lower(d.Name or "")
            if lname:find("display") or lname:find("name") or lname:find("owner") or lname:find("animal") then
                local txt = getTextFromInstance(d)
                if txt and txt ~= "" then return txt end
            end
        end
        return nil
    end

    if decorations then
        local decWithGen = findDescendantByNameCI(decorations, "Generation")
        if decWithGen then
            local res = extractFromDecorationNode(decWithGen)
            if res and res ~= "" then return res end
            if genInst then
                local prox = extractFromDecorationNode(genInst.Parent) or extractFromDecorationNode(genInst)
                if prox and prox ~= "" then return prox end
            end
        end
        for _, child in ipairs(decorations:GetChildren()) do
            local res = extractFromDecorationNode(child)
            if res and res ~= "" then return res end
        end
    end

    if podium then
        local oh = findDescendantByNameCI(podium, "AnimalOverhead")
        if oh then
            local disp = findDescendantByNameCI(oh, "DisplayName") or findDescendantByNameCI(oh, "Displayname")
            if disp then
                local txt = getTextFromInstance(disp)
                if txt and txt ~= "" then return txt end
            end
            local txt2 = getTextFromInstance(oh)
            if txt2 and txt2 ~= "" then return txt2 end
        end
    end

    if genInst then
        local p = genInst.Parent
        while p do
            local disp = findDescendantByNameCI(p, "DisplayName") or findDescendantByNameCI(p, "Displayname")
            if disp then
                local txt = getTextFromInstance(disp)
                if txt and txt ~= "" then return txt end
            end
            p = p.Parent
        end
    end

    if plot then
        local pdisp = findDescendantByNameCI(plot, "DisplayName") or findDescendantByNameCI(plot, "Displayname")
        if pdisp then
            local txt = getTextFromInstance(pdisp)
            if txt and txt ~= "" then return txt end
        end
        for _, d in ipairs(plot:GetDescendants()) do
            local lname = string.lower(d.Name or "")
            if lname:find("display") or lname:find("name") or lname:find("owner") or lname:find("animal") then
                local txt = getTextFromInstance(d)
                if txt and txt ~= "" then return txt end
            end
        end
    end

    if podium and podium.Name and podium.Name ~= "" then
        return tostring(podium.Name)
    end
    if plot and plot.Name and plot.Name ~= "" then
        return tostring(plot.Name)
    end
    return nil
end

local function findAllSecretAndOG10M()
    local plotsFolder = workspace:FindFirstChild(PLOTS_NAME)
    if not plotsFolder then
        for _, c in ipairs(workspace:GetChildren()) do
            if string.lower(c.Name) == string.lower(PLOTS_NAME) then 
                plotsFolder = c
                break 
            end
        end
    end
    if not plotsFolder then return {} end
    local results = {}
    for _, plot in ipairs(plotsFolder:GetChildren()) do
        local animalPodiums = plot:FindFirstChild("AnimalPodiums") or findDescendantByNameCI(plot, "AnimalPodiums")
        if animalPodiums then
            for _, podium in ipairs(animalPodiums:GetChildren()) do
                if isPodiumIndex(podium.Name) then
                    local base = findDescendantByNameCI(podium, "Base") or podium:FindFirstChild("Base")
                    local decorations = nil
                    if base then 
                        decorations = base:FindFirstChild("Decorations") or findDescendantByNameCI(base, "Decorations") 
                    end
                    if not decorations then 
                        decorations = podium:FindFirstChild("Decorations") or findDescendantByNameCI(podium, "Decorations") 
                    end
                    
                    local rarityText = getRarityForPodium(podium, decorations)
                    if rarityText then
                        local rlower = string.lower(rarityText)
                        
                        if string.find(rlower, "secret", 1, true) or string.find(rlower, "og", 1, true) then
                            local numeric, rawText, genInst = nil, nil, nil
                            
                            if decorations then
                                local n, t, g = findGenerationInDecorations(decorations)
                                if n then 
                                    numeric = n
                                    rawText = t
                                    genInst = g 
                                end
                            end
                            if not numeric then
                                local genInstCandidate = podium:FindFirstChild("Generation") or findDescendantByNameCI(podium, "Generation")
                                if not genInstCandidate then
                                    local overhead = podium:FindFirstChild("AnimalOverhead") or findDescendantByNameCI(podium, "AnimalOverhead")
                                    if overhead then 
                                        genInstCandidate = overhead:FindFirstChild("Generation") or findDescendantByNameCI(overhead, "Generation") 
                                    end
                                end
                                if genInstCandidate then
                                    local genText = getTextFromInstance(genInstCandidate)
                                    if genText then 
                                        numeric = parseSuffixNumber(genText)
                                        rawText = genText
                                        genInst = genInstCandidate 
                                    end
                                end
                            end

                            if numeric and numeric >= MIN_GENERATION then
                                local basePart = findBasePartForPodium(podium)
                                table.insert(results, {
                                    value = numeric or 0,
                                    numericValue = numeric or 0,
                                    rawText = rawText,
                                    podium = podium,
                                    plot = plot,
                                    basePart = basePart,
                                    decorations = decorations,
                                    rarity = rarityText,
                                    genInst = genInst
                                })
                            end
                        end
                    end
                end
            end
        end
    end
    return results
end

local function cleanGenerationString(raw)
    if not raw or type(raw) ~= "string" then return nil end
    local s = string.gsub(raw, "%s+", "")
    if string.sub(s,1,1) == "$" then s = string.sub(s,2) end
    s = string.gsub(s, "/.*$", "")
    s = string.gsub(s, "persecond", "")
    s = string.gsub(s, "pers", "")
    s = string.gsub(s, "persec", "")
    s = string.gsub(s, "per", "")
    s = string.gsub(s, "[^%w%.]+$", "")
    return s
end

local function sendWebhookList(entries)
    if not entries or #entries == 0 then
        warn("sendWebhookList: no entries to send")
        return false
    end
    if not WEBHOOK_URL or WEBHOOK_URL == "" then
        warn("sendWebhookList: webhook URL is empty")
        return false
    end

    table.sort(entries, function(a,b) 
        return (a.numericValue or 0) > (b.numericValue or 0) 
    end)
    
    local lines = {}
    local keyParts = {}
    local maxFieldEntries = 25
    
    for i, e in ipairs(entries) do
        local displayName = extractDisplayNameFollowingPath(e.plot, e.podium, e.decorations, e.genInst)
        if not displayName then 
            displayName = tostring(e.plot and e.plot.Name or "") .. "/" .. tostring(e.podium and e.podium.Name or "") 
        end
        local rarity = e.rarity or "-"
        local cleanedVal = e.rawText and cleanGenerationString(e.rawText) or (e.rarity or "-")
        local line = string.format("**#%d** | %s | %s | %s", i, cleanedVal, rarity, displayName)
        table.insert(lines, line)
        table.insert(keyParts, cleanedVal .. " " .. rarity)
        if i >= MAX_PLAYERS_DISPLAY then break end
    end

    local currentJobId = game.JobId or "N/A"
    local currentPlaceId = game.PlaceId or "N/A"
    local playersInServer = #Players:GetPlayers()
    
    local description = table.concat(lines, "\n")
    if description == "" then description = "No data." end
    
    local key = table.concat(keyParts, " | ")
    if #key > 100 then key = string.sub(key, 1, 100) .. "..." end
    
    local embed = {
        title = "ðŸ”¥ Secret/OG Pets (>= 10M Generation)",
        description = description,
        color = 3447003,
        fields = {
            { name = "Job ID", value = tostring(currentJobId), inline = true },
            { name = "Place ID", value = tostring(currentPlaceId), inline = true },
            { name = "Players", value = tostring(playersInServer), inline = true }
        },
        footer = { text = "Auto Hop Script | " .. os.date("%Y-%m-%d %H:%M:%S") },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local payload = {
        username = "Plot Scanner",
        avatar_url = "https://i.imgur.com/AfFp7pu.png",
        embeds = { embed },
        content = "**Key:** " .. key
    }
    
    local jsonBody = HttpService:JSONEncode(payload)
    local success, response = doHttpRequest({
        Url = WEBHOOK_URL,
        Method = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body = jsonBody
    })
    
    if success and response and response.Success then
        print("[WEBHOOK] Successfully sent to Discord")
        return true
    else
        warn("[WEBHOOK] Failed to send:", response and response.Body or "unknown error")
        return false
    end
end

local function safelyTeleportToServer(placeId, jobId, maxRetries)
    maxRetries = maxRetries or TELEPORT_MAX_RETRIES
    local retryCount = 0
    
    local function attemptTeleport()
        retryCount = retryCount + 1
        print(string.format("[TELEPORT] Attempt %d/%d - Teleporting to JobId: %s", retryCount, maxRetries, tostring(jobId)))
        
        if not jobId or jobId == "" then
            warn("[TELEPORT] Invalid JobId provided")
            return false
        end
        
        local teleportOptions = Instance.new("TeleportOptions")
        teleportOptions.ServerInstanceId = jobId
        
        local success, errorMsg = pcall(function()
            TeleportService:TeleportAsync(placeId, {player}, teleportOptions)
        end)
        
        if success then
            print("[TELEPORT] Teleport initiated successfully!")
            return true
        else
            warn(string.format("[TELEPORT] Failed (attempt %d): %s", retryCount, tostring(errorMsg)))
            return false
        end
    end
    
    local teleportConnection
    teleportConnection = TeleportService.TeleportInitFailed:Connect(function(plr, teleportResult, errorMessage, placeIdFailed, teleportOptions)
        if plr == player then
            warn(string.format("[TELEPORT] TeleportInitFailed: %s (Result: %s)", tostring(errorMessage), tostring(teleportResult)))
            
            if retryCount < maxRetries then
                print(string.format("[TELEPORT] Retrying in %d seconds...", TELEPORT_RETRY_DELAY))
                wait(TELEPORT_RETRY_DELAY)
                attemptTeleport()
            else
                warn("[TELEPORT] Max retries reached. Teleport failed completely.")
                if teleportConnection then
                    teleportConnection:Disconnect()
                end
            end
        end
    end)
    
    local result = attemptTeleport()
    
    if not result then
        task.wait(2)
        if teleportConnection then
            teleportConnection:Disconnect()
        end
    end
    
    return result
end

local function getServerList(placeId, cursor)
    cursor = cursor or ""
    local excludeFullGames = true
    local url = string.format(
        "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=%s&cursor=%s",
        tostring(placeId),
        tostring(excludeFullGames),
        cursor
    )
    
    local success, response = doHttpRequest({
        Url = url,
        Method = "GET",
        Headers = {}
    })
    
    if not success or not response or not response.Success then
        warn("[SERVER_LIST] Failed to fetch server list")
        return nil
    end
    
    local decoded
    local okDecode, decodeResult = pcall(function()
        return HttpService:JSONDecode(response.Body)
    end)
    
    if not okDecode or not decodeResult then
        warn("[SERVER_LIST] Failed to decode JSON")
        return nil
    end
    
    decoded = decodeResult
    return decoded
end

local function hopToRandomServer()
    local placeId = game.PlaceId
    local currentJobId = game.JobId
    print("[HOP] Starting server hop process...")
    
    local allServers = {}
    local cursor = ""
    local pageCount = 0
    
    while pageCount < MAX_SERVER_PAGES do
        local serverData = getServerList(placeId, cursor)
        if not serverData or not serverData.data then
            warn("[HOP] No more server data available")
            break
        end
        
        for _, server in ipairs(serverData.data) do
            if server.id and server.id ~= currentJobId and server.playing and server.playing > 0 then
                table.insert(allServers, server)
            end
        end
        
        pageCount = pageCount + 1
        if serverData.nextPageCursor and serverData.nextPageCursor ~= "" then
            cursor = serverData.nextPageCursor
        else
            break
        end
        
        wait(0.5)
    end
    
    print(string.format("[HOP] Found %d available servers", #allServers))
    
    if #allServers == 0 then
        warn("[HOP] No servers found to hop to")
        return false
    end
    
    local randomServer = allServers[math.random(1, #allServers)]
    print(string.format("[HOP] Selected server with %d players (JobId: %s)", randomServer.playing, randomServer.id))
    
    return safelyTeleportToServer(placeId, randomServer.id)
end

local function mainLoop()
    print("=== SCRIPT STARTED ===")
    print("Searching for Secret/OG pets with generation >= 10M...")
    
    wait(3)
    
    local found = findAllSecretAndOG10M()
    print(string.format("[SCAN] Found %d qualifying pets in this server", #found))
    
    if #found > 0 then
        clearESP()
        
        table.sort(found, function(a,b) 
            return (a.numericValue or 0) > (b.numericValue or 0) 
        end)
        
        local best = found[1]
        if best then
            print(string.format("[BEST] Highest Generation: %s (Rarity: %s)", 
                tostring(best.rawText), 
                tostring(best.rarity)
            ))
            
            if best.basePart then
                createBillboardForPart(best.basePart, "BEST: " .. tostring(best.rawText))
            end
            highlightBestPodiumDecorations(best.podium, best.decorations)
        end
        
        sendWebhookList(found)
    else
        print("[SCAN] No qualifying pets found in this server")
    end
    
    print(string.format("[HOP] Waiting %d seconds before hopping to next server...", HOP_DELAY_SECONDS))
    wait(HOP_DELAY_SECONDS)
    
    hopToRandomServer()
end

spawn(function()
    local success, err = pcall(mainLoop)
    if not success then
        warn("[ERROR] Main loop failed:", err)
    end
end)
